param (
	[Parameter(Mandatory=$false, Position=0)]
	[string]$NameVm,
	[Parameter(Mandatory=$false, Position=1)]
	[string]$PathToFile,
	[Parameter(Mandatory=$false, Position=2)]
	[string]$WinISO,
	[Parameter(Mandatory=$false, Position=3)]
	[string]$memory,
	[Parameter(Mandatory=$false, Position=4)]
	[string]$VHDSize,
	[Parameter(Mandatory=$false, Position=5)]
	[int]$Generation,
	[Parameter(Mandatory=$false, Position=6)]
	[string]$Network,
	[Parameter(Mandatory=$false, Position=7)]
	[int]$AmountOfVms,
	[Parameter(Mandatory=$false, Position=8)]
	[string]$Skipp,
	[Parameter(Mandatory=$false, Position=9)]
	[string]$dbug
)

#jag vet att det finns procceses och att man kan dela up uppgifter s친 att saker g친r fortare.... im a noob and lazy i can wait
#implementeringen skulle vara vid main
$VMName = "vm"

$Path = "C:/Users/$env:username/VM/"

#CreatVM variabler
$ISO = "$Path/Disk/Windows.iso"
$MemoryStartup = 3GB
$NewVHDSize = 13GB
$Gen = 2
$NeT = "LOCAL"#kanske skulle ha fixat egen NeT men det 칛r inte uppgiften:)


#loginuser har en variabel som inte ska finnas men d친 jag skapat ison med User1
$AdminNamn = "admin"#konvertera desa tv친 till en fil med ett hashad l칬senord... but in not here for best practesis
$AdminPw = "123"

$Users = @($AdminNamn,$AdminNamn+"A",$AdminNamn+"B")
#$user2 = $AdminNamn+"B"

$Skript = "Account_folders.ps1"

#G칬r dena varibalen om jag nong친ng i framtiden k칛nner f칬r att anv칛nda 游뱍 windows. f칬r att skapa flera vms 칛n 2.
$NrOfVms = 3

#ignor this this is shit programers like like and list starts with 0 and not 1
$NrOfVms = $NrOfVms - 1

#"yes" f칬r att skipa att f친 fr친gan om att trycka enter och popup f칬r att trycka i vmet
#och 칛ven st칛nga av raderingen av VM:et och skapandet

$skip = "no"
#"yes" st칛nger av clear-host och lite andra kommentar och s칛tter p친 ett par andra kommentar f칬r mer debug
$debug = "no"

$clean = $false


if($NameVm -ne ""){$VMName = $NameVm}
if($PathToFile -ne ""){$Path = $PathToFile}
if($WinISO -ne ""){$ISO = $WinISO}
if($memory -ne ""){$MemoryStartup = $memory}
if($VHDSize -ne ""){$NewVHDSize = $VHDSize}
if($Generation -ne ""){$Gen = $Generation}
if($Network -ne ""){$NeT = $Network}
if($AntalVms -ne ""){$NrOfVms = $AntalVms}
if($Skipp -ne ""){$skip = $Skipp}
if($dbug -ne ""){$debug = $dbug}
if($debug -eq "yes"){
	Write-Host
	Write-Host $PathToFile
	Write-Host $WinISO
	Write-Host $memory
	Write-Host $VHDSize
	Write-Host $Generation
	Write-Host $Network
	Write-Host $AntalVms
	Write-Host $Skipp
	Write-Host $dbug
}


function main{
	#Clear-Host
	#jag har alltid anv칛nt "i" som en loop varibel. men varf칬r... varf칬r anv칛ns i sen j, i loops?
	$VMNr = 0
	while ($VMNr -le $NrOfVms){
		$round = 0
		if ($skip -ne "yes") {
			RemoveVM($VMNr)
			CreatVM($VMNr)
		}
		StopVM($VMNr)
		while ($round -le 1) {
			if($round -eq "1" -and $VMNr -eq 1){
				$user = $Users[1]
			}
			else {
				$user = $Users[0]
			}
			if($round -eq 1 -or $skip -eq "yes"){$skipCD = "yes"}
			if((StartVM -VMNr $VMNr -skip $skipCD -user $user)){
				if($debug -eq "yes"){Write-Host "its running the vm setup $user for $name$VMNr round $round"}
				SendFile -VMNr $VMNr -round $round -user $user
				if($skipCD -ne "yes"){StopVM($VMNr)}#ass친 dena koden blir spagheti nu i slutet, 칛r f칬r tr칬tt
				Start-Sleep -Seconds 5
			}
			$round++
		}
		#StartVM -VMNr $VMNr -skip "yes"
		if($debug -eq "yes"){Write-Host "done with $VMName$VMNr"}
		$skipCD = "no"
		$VMNr++
	}
	#this needs to be in a loop to clean both vm's after that everythin is done
	if($skip -ne "yes"){
		cleanUpVMs
	}
	if($debug -eq "yes"){Write-Host "everything is done"}
}
function cleanUpVMs{
	$VMNr = 0
	while ($VMNr -le $NrOfVms) {
		Write-Host "Do you want to clean up files on the vm$VMNr yes/NO"
		$vmclean = ((Read-Host).ToLower()).ToCharArray()[0]
		if($vmclean -eq "y"){
			if((StartVM -VMNr $VMNr -skip "yes")){
				if($debug -eq "yes"){Write-Host "cleaning $name$VMNr"}
				$clean = $true
				SendFile -VMNr $VMNr -clear $clean
			}
		}
		$VMNr++
	}
}
function StartVM{
	param (
		[Parameter(Mandatory=$true, Position=0)]
		[int]
		$VMNr,
		[Parameter(Mandatory=$false, Position=1)]
		[string]
		$skip,
		[Parameter(Mandatory=$false, Position=2)]
		[string]
		$user
		)
	$folder = $false
	$procesBool = $false
	$VMName = $VMName + $VMNr
	[int]$randomloopshit = 0
	Start-VM $VMName

	if($skip -eq "yes"){
		$ans = ""
	}
	else {
		vmconnect.exe $env:computername "$VMName"
		<#
		skit samma h칛r borde man egentligen vara n친gon slaggs "sendkeys"
		men d친 jag inte vill ladda ner on칬dig skit s친 f친r de la n칬ja dig med en pop up:D
		#>

		#Stealing this from a clssmate
		Write-Host "press ENTER if you have passd the CD DVD sheats"
		$ans = Read-Host
	}
	#3 steps... i know its bad but its not and if if if statment :D
	if ($ans -eq "") {
		if($debug -ne "yes"){
			Clear-Host
			Write-Host "Waiting for windows to complet and login"
			Write-Host "Skript is not frozzen C: $dot"
		}
		else{
			Write-host "starting the invoke tests $VMNr"
		}
		if($skip -ne "yes"){
			TASKKILL /IM vmconnect.exe /F
		}
		while($true){
		#finns s칛kert finare s칛tt att l칬sa deta... dvs att kolla om allt 칛r laddat
			Start-Sleep -Seconds 1
			$dot = "." * ([int]$randomloopshit)
			try {
				$folder = Invoke-Command -VMName $VMName -Credential (UserLogin($user)) -ScriptBlock{
					Test-Path -Path "C:\"
				} -ErrorAction Stop
				if ($folder) {
					$proces = Invoke-Command -VMName $VMName -Credential (UserLogin($user)) -ScriptBlock{
						(Get-Service -Name vmicheartbeat).Status
					}-ErrorAction Stop
					#jag sat uppe till klockan 2:40 f칬r att $proces 칛r inte en "Running" String. love this....
					if(([string]$proces) -eq "Running"){
						$procesBool = $true
					}
				}
			}
			catch {
				if($debug -ne "yes"){
				Clear-Host
				Write-Host "Waiting for windows to complet and login"
				Write-Host "Skript is not frozzen C: $dot"
				}
				else{
					Start-Sleep -Seconds 1
					Write-Host "$dot"
				}
			}
			if($debug -eq "yes"){Write-Host "$VMName Folder is $folder and Process $procesBool"}
			if($folder -and $procesBool){
				return $true
				break
			}
			$randomloopshit++
			if($randomloopshit -cgt 3){
				$randomloopshit = 0
			}
		}
	}
	else {
		Write-Host "Skript restarts, Did not press enter"
		main
	}
}
function SendFile{
	#jag vet deta 칛r inte en bra l칬sning att convertera $vmname varjeg친ng... men orkar ej
	param (
		[Parameter(Mandatory=$true, Position=0)]
		[int]
		$VMNr,
		[Parameter(Mandatory=$false, Position=1)]
		[int]
		$round,
		[Parameter(Mandatory=$false, Position=2)]
		[bool]
		$clear,
		[Parameter(Mandatory=$false, Position=3)]
		[string]
		$user
	)
	$VMName = $VMName + $VMNr
	if($debug -eq "yes"){Write-Host "SendFile to $VMName"}
	$s = New-PSSession -VMName $VMName -Credential (UserLogin($user))
	#nu n칛r jag an칛vnder $round borde jag ta bort $HostName f칬r den g칬r det samma i den andra filen vilket 칛ven tar bort $vm2 vilket inte 칛r en bra
	$HostName = Invoke-Command -VMName $VMName -Credential (UserLogin($user)) -ScriptBlock{$env:COMPUTERNAME}
	Invoke-Command -VMName $VMName -Credential (UserLogin($user)) -FilePath $Skript -ArgumentList $VMName, $VMNr, $HostName, $debug, $Users[0], $round, $clean
	if($VMNr -eq 0 -and $round -eq 0){
		Copy-Item -ToSession $s -Path .\Send.txt -Destination "C:\Temp\RW\"
	}
}
function UserLogin($user){
	$Pass = ConvertTo-SecureString -String $AdminPw -AsPlainText -Force
	$Creds = New-Object System.Management.Automation.PSCredential("$user", $Pass)
return $Creds
}
function CheckVMStatus($VMNr){
	if ($null -eq (Get-VM -Name $VMName)){
		if($debug -eq "yes"){Write-Host "theres no VM on the system"}
		return $false
	}
	else{
		if($debug -eq "yes"){Write-Host "theres vm's on the system"}
		return $true

	}
}
function RemoveVM($VMNr){
	#T칛nkte egentligen att anv칛nda += men verka inte funka s친 som jag t칛nkte
	$VMName = $VMName + $VMNr
	$VHD = "$Path/Drive/$VMName.vhdx"
	if((CheckVMStatus($VMnr))){
		try {
			Stop-VM -Name $VMName -Force -ErrorAction Ignore
			Remove-VM -Name $VMName -Force -ErrorAction Ignore
		}
		catch {
			Write-Host "VM already stoped or doesnt exist"
			Write-Host "no cleaning needed for $VMName"
		}
	}
	try {
		Remove-Item -Path "$Path$VMName","$VHD" -Exclude *.iso -Recurse -ErrorAction Ignore
	}
	catch {
		Write-Host "Nothing to clean in $Path$VMName, $VHD"
	}
}
function CreatVM($VMNr){
	$VMName = $VMName + $VMNr
	$VHD = "$Path/Drive/$VMName.vhdx"
	$VMPath = "$Path$VMName"

	New-VM -Name $VMName -MemoryStartupBytes $MemoryStartup -Path $VMPath -newVHDPath $VHD -NewVHDSizeBytes $NewVHDSize -Generation $Gen -SwitchName $NeT

	if((CheckVMStatus($VMNr))){
		Add-VMDvdDrive -VMName $VMName -Path $ISO

		$vmDrive = Get-VMDvdDrive -VMName $VMName
		#hadde problem med att iso:n inte ville boota i gen 1 s친 gjorde den typ compatible med b친de...
		try {
			Set-VMFirmware $VMName -BootOrder $vmDrive -EnableSecureBoot Off
		}
		catch {
			try {
				Set-VMBios "$VMName" -StartupOrder CD -ErrorAction Stop
			}
			catch {
				Write-Host "it complains about VMBios and VMFirmware for $VMName"
			}
		}
	}
}
function StopVM($VMNr){
	Stop-VM $VMName$VMNr -TurnOff -Force
}
function RestartVM($VMNr){
	Restart-VM $VMName$VMNr -Force
}
function CreatXMLFile{
	param(
		[string]$adminAcc,
		[string]$PcName,
		[System.Security.SecureString]$Password
	)
	Remove-Item .\autounattend.xml -Force
#	$Unattend = [xml] (Get-Content .\DontChangeThis.xml)


}
function test {
i#	$Unattend = [xml] (Get-Content DontChangeThis.xml)
	#$Unattend -ireplace
}

#test
main